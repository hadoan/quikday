# Approval Flow Architecture

## Overview

This document describes the systematic approval flow implementation using the **State Pattern** and **Command Pattern** design patterns. The approval flow allows users to review and approve execution plans before they are executed.

## Design Patterns

### State Pattern
The run lifecycle follows a clear state machine:
- `planning` → Plan being generated by LLM
- `awaiting_approval` → Plan ready, waiting for user approval
- `approved` → User approved, ready to execute
- `executing` → Executor running steps
- `completed` / `failed` → Final states

### Command Pattern
User approval actions are encapsulated as commands:
- **ApproveCommand**: Approves plan and resumes execution
- **RejectCommand**: Cancels run and prevents execution

## Flow Diagram

```
User Prompt
    ↓
classify (intent detection)
    ↓
planner (generate execution plan)
    ↓
[HALT - Check if approval needed]
    ↓
YES → Set status: awaiting_approval
    ↓
Persist plan to DB & Send WebSocket event to UI
    ↓
UI displays plan with Approve/Reject buttons
    ↓
User clicks "Approve" → POST /runs/:id/approve
    ↓
Backend:
  - Validate status = awaiting_approval
  - Update status → approved
  - Store approvedSteps in config
  - Re-enqueue run with resumeFrom: 'executor'
    ↓
Processor:
  - Detect resumeFrom = executor
  - Skip classify & planner
  - Execute from executor node directly
    ↓
executor (run approved steps)
    ↓
summarize (generate summary)
    ↓
completed
```

## Key Components

### 1. Graph Flow Control (`packages/agent/buildMainGraph.ts`)

**Decision Point After Planner:**
```typescript
.addEdge('planner', (s) => {
  const plan = s.scratch?.plan ?? [];
  const hasExecutableSteps = plan.length > 0 && 
    !plan.every((st) => st.tool === 'chat.respond');
  
  // If AUTO mode with executable steps, halt for approval
  if (s.mode === 'AUTO' && hasExecutableSteps) {
    (s.scratch as any).requiresApproval = true;
    return 'END'; // Halt graph here
  }
  
  // PLAN mode or chat-only: proceed to confirm
  return 'confirm';
})
```

**Why this works:**
- In AUTO mode, planner generates plan and graph halts
- Processor detects `requiresApproval` flag and sets status to `awaiting_approval`
- Graph doesn't continue to executor automatically

### 2. Processor Approval Detection (`apps/api/src/queue/run.processor.ts`)

**After Graph Completes:**
```typescript
const requiresApproval = (final?.scratch as any)?.requiresApproval === true;
const plan = (final?.scratch?.plan ?? []) as Array<{ id: string; tool: string }>;
const hasExecutableSteps = plan.length > 0 && 
  !plan.every((st) => st.tool === 'chat.respond');

if (requiresApproval && hasExecutableSteps) {
  // Persist plan
  await this.runs.persistResult(run.id, {
    output: final.output,
    logs: formatLogsForPersistence(),
  });

  // Set status to awaiting_approval
  await this.runs.updateStatus(run.id, 'awaiting_approval');

  // Notify UI
  await this.eventBus.publish(run.id, { 
    type: 'run_status', 
    payload: { 
      status: 'awaiting_approval',
      plan: plan.map(s => ({ id: s.id, tool: s.tool }))
    } 
  }, CHANNEL_WEBSOCKET);
  
  return; // Stop here, wait for approval
}
```

### 3. Approval Endpoint (`apps/api/src/runs/runs.service.ts`)

**Approval Handler:**
```typescript
async approveSteps(runId: string, approvedSteps: string[]) {
  const run = await this.prisma.run.findUnique({ where: { id: runId } });
  if (!run) throw new NotFoundException('Run not found');

  // Verify correct state
  if (run.status !== 'awaiting_approval') {
    throw new BadRequestException(
      `Cannot approve run with status '${run.status}'`
    );
  }

  const config = this.asRecord(run.config);
  
  // Store approval data and resume point
  const nextConfig = { 
    ...config, 
    approvedSteps,
    resumeFrom: 'executor' // Signal to resume from executor
  };

  // Update status to approved
  await this.prisma.run.update({
    where: { id: runId },
    data: {
      config: nextConfig,
      status: 'approved',
    },
  });

  // Re-enqueue with continuation signal
  await this.enqueue(runId, { 
    scratch: { 
      approvalGranted: true,
      approvedAt: new Date().toISOString()
    } 
  });

  await this.telemetry.track('run_approved', { runId, stepsCount: approvedSteps.length });
}
```

**Why this works:**
- Validates state transition (only from `awaiting_approval`)
- Sets `resumeFrom: 'executor'` to skip planning phase
- Re-queues run with approval metadata
- Updates telemetry for tracking

### 4. Resume Execution (`apps/api/src/queue/run.processor.ts`)

**Graph Entry Point Selection:**
```typescript
// Check if we're resuming from a specific node
const config = run.config as any;
const resumeFrom = config?.resumeFrom as string | undefined;

if (resumeFrom === 'executor' && run.status === 'approved') {
  // Resume execution from executor node after approval
  this.logger.log('▶️ Resuming from executor after approval', {
    runId: run.id,
    approvedSteps: config?.approvedSteps?.length || 0,
  });
  
  // Run from executor directly, bypassing planner
  final = await graph.run('executor', initialState, this.eventBus);
} else {
  // Normal flow: start from classify
  final = await graph.run('classify', initialState, this.eventBus);
}
```

**Why this works:**
- Detects `resumeFrom: 'executor'` signal in config
- Validates run is in `approved` state
- Starts graph execution from executor node
- Skips classify → planner flow entirely
- Plan is already in `initialState.scratch.plan`

### 5. UI Components

#### PlanCard (`apps/web/src/components/cards/PlanCard.tsx`)

**Enhanced Approval UI:**
```typescript
{onConfirm && (
  <div className="border-t pt-4 mt-4 space-y-2">
    <div className="flex items-center justify-between gap-2">
      <p className="text-sm font-medium text-foreground">
        Review this plan before execution
      </p>
      <Badge variant="outline" className="text-xs">
        Awaiting Approval
      </Badge>
    </div>
    <div className="flex justify-end gap-2">
      {onReject && (
        <Button onClick={handleReject} variant="outline" size="sm">
          <X className="h-4 w-4" />
          Reject
        </Button>
      )}
      <Button onClick={handleApprove} size="sm">
        <ThumbsUp className="h-4 w-4" />
        Approve & Execute
      </Button>
    </div>
  </div>
)}
```

**Features:**
- Clear visual indication of approval state
- Separate approve/reject actions
- Loading states during API calls
- Error handling with console logging

#### ChatStream Integration (`apps/web/src/components/chat/ChatStream.tsx`)

```typescript
const canApprove = flags.liveApprovals && 
  runId && 
  lastStatus === 'awaiting_approval' && 
  steps.length > 0;

const onConfirm = canApprove
  ? async () => {
      try {
        await dataSource.approve(runId, steps.map((s) => s.id));
      } catch (e) {
        console.error('approve failed', e);
      }
    }
  : undefined;

const onReject = canApprove
  ? async () => {
      try {
        await dataSource.cancel(runId);
      } catch (e) {
        console.error('reject failed', e);
      }
    }
  : undefined;
```

## State Transitions

### Valid Transitions

```
queued → planning → awaiting_approval → approved → executing → completed
                                      ↘ canceled (on reject)
```

### Invalid Transitions (Rejected by Backend)

- `executing` → `awaiting_approval` ❌
- `completed` → `approved` ❌
- `failed` → `approved` ❌

## Security Considerations

1. **State Validation**: Backend enforces state machine rules
2. **Authorization**: Only authenticated users can approve their runs
3. **Team Permissions**: Team-level approvals respect team membership
4. **Audit Trail**: All approvals logged to telemetry

## Performance Characteristics

- **Latency**: Approval adds user interaction time (blocking)
- **Memory**: Plan stored in run.output until execution
- **Queue**: Approved runs re-enter queue with normal priority
- **Idempotency**: Re-enqueue uses unique job IDs to prevent duplicates

## Testing Strategy

### Unit Tests
- State transitions validation
- Graph edge conditions
- Approval endpoint validation

### Integration Tests
- End-to-end approval flow
- WebSocket event delivery
- Resume execution correctness

### Manual Testing Checklist
- ✅ Plan generates correctly
- ✅ UI shows approval buttons
- ✅ Approve button triggers execution
- ✅ Reject button cancels run
- ✅ WebSocket updates in real-time
- ✅ Execution completes successfully
- ✅ Telemetry captures events

## Future Enhancements

1. **Multi-level Approvals**: Team lead → Manager approval chain
2. **Partial Approval**: Approve subset of steps
3. **Approval Timeout**: Auto-reject after timeout
4. **Approval History**: Track who approved what and when
5. **Conditional Approval**: Auto-approve based on rules

## Related Files

- `packages/agent/buildMainGraph.ts` - Graph flow control
- `apps/api/src/queue/run.processor.ts` - Processor logic
- `apps/api/src/runs/runs.service.ts` - Approval handler
- `apps/api/src/runs/runs.controller.ts` - API endpoint
- `apps/web/src/components/cards/PlanCard.tsx` - Approval UI
- `apps/web/src/components/chat/ChatStream.tsx` - Integration
- `apps/web/src/lib/datasources/DataSource.ts` - Interface definition

## Troubleshooting

### Plan doesn't show approval UI
- Check `liveApprovals` feature flag is enabled
- Verify run status is `awaiting_approval`
- Ensure steps array is populated

### Approval doesn't trigger execution
- Check backend logs for errors
- Verify run status transitions correctly
- Ensure BullMQ queue is processing jobs

### Execution starts from planner again
- Verify `resumeFrom: 'executor'` is in config
- Check processor resume logic
- Ensure graph.run() receives correct entry point

---

© 2025 Quik.day - Built with systematic design patterns for reliable approval flows
