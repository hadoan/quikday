generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum Plan {
    FREE
    PRO
}

model User {
    id           Int          @id @default(autoincrement())
    sub          String       @unique
    email        String?      @unique
    displayName  String?
    avatar       String?
    plan         Plan         @default(PRO)
    lastLoginAt  DateTime?
    createdAt    DateTime     @default(now())
    // updatedAt intentionally omitted to allow non-destructive db push in dev
    teams        TeamMember[]
    runs         Run[]
    workspace    Workspace?
    Credential   Credential[]
    ApiKey       ApiKey[]
}

model Workspace {
    id           Int       @id @default(autoincrement())
    name         String
    slug         String    @unique
    plan         Plan      @default(PRO)
    ownerUserId  Int       @unique
    owner        User      @relation(fields: [ownerUserId], references: [id])
    createdAt    DateTime  @default(now())
    updatedAt    DateTime  @updatedAt
}

model Team {
    id           Int           @id @default(autoincrement())
    name         String
    members      TeamMember[]
    policies     Policy[]
    integrations Integration[]
    runs         Run[]
    createdAt    DateTime      @default(now())
    Credential   Credential[]
}

model TeamMember {
    id     Int    @id @default(autoincrement())
    teamId Int
    userId Int
    role   String
    Team   Team   @relation(fields: [teamId], references: [id])
    User   User   @relation(fields: [userId], references: [id])

    @@unique([teamId, userId])
}

model Policy {
    id     Int     @id @default(autoincrement())
    teamId Int
    key    String
    value  Boolean
    Team   Team    @relation(fields: [teamId], references: [id])
}

model Integration {
    id                 Int       @id @default(autoincrement())
    teamId             Int
    provider           String
    status             String
    accessTokenCipher  Bytes?
    refreshTokenCipher Bytes?
    expiresAt          DateTime?
    Team               Team      @relation(fields: [teamId], references: [id])
}

model Run {
    id            String         @id @default(cuid())
    teamId        Int?
    userId        Int
    prompt        String
    mode          String
    status        String
    intent        Json?
    config        Json?
    output        Json?
    error         Json?
    scheduledAt   DateTime?
    toolAllowlist Json?
    policySnapshot Json?
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt
    steps         Step[]
    effects       RunEffect[]
    RunScopedKeys RunScopedKey[]
    Team          Team?          @relation(fields: [teamId], references: [id])
    User          User           @relation(fields: [userId], references: [id])
}

model Step {
    id           Int       @id @default(autoincrement())
    runId        String
    tool         String
    action       String
    appId        String?
    credentialId Int?
    request      Json?
    response     Json?
    errorCode    String?
    startedAt    DateTime  @default(now())
    endedAt      DateTime?
    Run          Run       @relation(fields: [runId], references: [id])
}

model RunScopedKey {
    id          Int      @id @default(autoincrement())
    runId       String
    provider    String
    scope       String
    tokenCipher Bytes
    expiresAt   DateTime
    Run         Run      @relation(fields: [runId], references: [id])
}

model RunEffect {
    id              Int      @id @default(autoincrement())
    runId           String
    stepId          Int?
    appId           String
    credentialId    Int
    action          String
    externalRef     String?
    idempotencyKey  String   @unique
    undoStrategy    String?
    canUndo         Boolean  @default(false)
    undoneAt        DateTime?
    metadata        Json?
    createdAt       DateTime @default(now())
    Run             Run      @relation(fields: [runId], references: [id])

    @@index([runId])
    @@index([idempotencyKey])
}

model Credential {
    id                   Int       @id @default(autoincrement())
    type                 String
    key                  Json
    user                 User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId               Int?
    app                  App       @relation(fields: [appId], references: [slug], onDelete: Cascade)
    appId                String
    invalid              Boolean   @default(false)
    Team                 Team?     @relation(fields: [teamId], references: [id])
    teamId               Int?
    isUserCurrentProfile Boolean   @default(false)
    isTeamDefaultProfile Boolean   @default(false)
    emailOrUserName      String?
    avatarUrl            String?
    name                 String?
    vendorAccountId      String?
    tokenExpiresAt       DateTime?
    lastValidatedAt      DateTime?
    createdAt            DateTime  @default(now())
    updatedAt            DateTime  @updatedAt

    @@unique([userId, appId, emailOrUserName])
    @@index([userId])
    @@index([appId])
    @@index([teamId])
}

enum AppCategories {
    calendar
    email
    messaging
    other
    payment
    web3
    automation
    analytics
    conferencing
    crm
    social
    cloudstorage
    ai
}

model App {
    // The slug for the app store public page inside `/apps/[slug]`
    slug        String          @id @unique
    // The directory name for `/packages/app-store/[dirName]`
    dirName     String          @unique
    // Needed API Keys
    keys        Json?
    // One or multiple categories to which this app belongs
    categories  AppCategories[]
    createdAt   DateTime        @default(now())
    updatedAt   DateTime        @updatedAt
    credentials Credential[]
    ApiKey      ApiKey[]
    enabled     Boolean         @default(false)

    @@index([enabled])
}

model ApiKey {
    id         String    @id @unique @default(cuid())
    userId     Int
    note       String?
    createdAt  DateTime  @default(now())
    expiresAt  DateTime?
    lastUsedAt DateTime?
    hashedKey  String    @unique()
    user       User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
    app        App?      @relation(fields: [appId], references: [slug], onDelete: Cascade)
    appId      String?

    @@index([userId])
}

// Simple landing waitlist for beta signups
model Waitlist {
    id        Int      @id @default(autoincrement())
    email     String   @unique
    role      String?
    teamSize  String?
    useCase   String?
    createdAt DateTime @default(now())
}
