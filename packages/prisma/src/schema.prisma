generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum Plan {
    FREE
    PRO
}

model User {
    id           Int          @id @default(autoincrement())
    sub          String       @unique
    email        String?      @unique
    displayName  String?
    avatar       String?
    plan         Plan         @default(PRO)
    lastLoginAt  DateTime?
    createdAt    DateTime     @default(now())
    // updatedAt intentionally omitted to allow non-destructive db push in dev
    teams        TeamMember[]
    runs         Run[]
    workspace    Workspace?
    Credential   Credential[]
    ApiKey       ApiKey[]
    LLMLogs      LLMLog[]
    chats        Chat[]       @relation("UserChats")
    chatItems    ChatItem[]   @relation("UserChatItems")
}

model Workspace {
    id           Int       @id @default(autoincrement())
    name         String
    slug         String    @unique
    plan         Plan      @default(PRO)
    ownerUserId  Int       @unique
    owner        User      @relation(fields: [ownerUserId], references: [id])
    createdAt    DateTime  @default(now())
    updatedAt    DateTime  @updatedAt
}

model Team {
    id           Int           @id @default(autoincrement())
    name         String
    members      TeamMember[]
    policies     Policy[]
    integrations Integration[]
    runs         Run[]
    createdAt    DateTime      @default(now())
    Credential   Credential[]
    LLMLogs      LLMLog[]
    chats        Chat[]       @relation("TeamChats")
    chatItems    ChatItem[]   @relation("TeamChatItems")
}

model TeamMember {
    id     Int    @id @default(autoincrement())
    teamId Int
    userId Int
    role   String
    Team   Team   @relation(fields: [teamId], references: [id])
    User   User   @relation(fields: [userId], references: [id])

    @@unique([teamId, userId])
}

model Policy {
    id     Int     @id @default(autoincrement())
    teamId Int
    key    String
    value  Boolean
    Team   Team    @relation(fields: [teamId], references: [id])
}

model Integration {
    id                 Int       @id @default(autoincrement())
    teamId             Int
    provider           String
    status             String
    accessTokenCipher  Bytes?
    refreshTokenCipher Bytes?
    expiresAt          DateTime?
    Team               Team      @relation(fields: [teamId], references: [id])
}

model Run {
    id            String         @id @default(cuid())
    teamId        Int?
    userId        Int
    prompt        String
    mode          String
    status        String
    intent        Json?
    config        Json?
    output        Json?
    error         Json?
    scheduledAt   DateTime?
    toolAllowlist Json?
    policySnapshot Json?
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt
    steps         Step[]
    effects       RunEffect[]
    RunScopedKeys RunScopedKey[]
    Team          Team?          @relation(fields: [teamId], references: [id])
    User          User           @relation(fields: [userId], references: [id])
    chat          Chat?          @relation("RunChat")
    chatItems     ChatItem[]     @relation("RunChatItems")
}

model Chat {
    id        String   @id @default(cuid())
    runId     String   @unique
    userId    Int
    teamId    Int?
    title     String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    Run   Run   @relation("RunChat", fields: [runId], references: [id], onDelete: Cascade)
    User  User  @relation("UserChats", fields: [userId], references: [id])
    Team  Team? @relation("TeamChats", fields: [teamId], references: [id])
    items ChatItem[]

    @@index([userId, createdAt])
    @@index([teamId, createdAt])
}

model ChatItem {
    id        String   @id @default(cuid())
    chatId    String
    type      String
    role      String?
    content   Json?
    runId     String?
    userId    Int?
    teamId    Int?
    createdAt DateTime @default(now())

    Chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
    Run  Run? @relation("RunChatItems", fields: [runId], references: [id])
    User User? @relation("UserChatItems", fields: [userId], references: [id])
    Team Team? @relation("TeamChatItems", fields: [teamId], references: [id])

    @@index([chatId, createdAt])
    @@index([runId, createdAt])
}

model Step {
    id           Int       @id @default(autoincrement())
    runId        String
    tool         String
    action       String
    appId        String?
    credentialId Int?
    request      Json?
    response     Json?
    errorCode    String?
    // The planner/executor step id (e.g., "step-02-0") to correlate with plan
    planStepId   String?
    // Whether this step was waiting for explicit confirmation before execution
    waitingConfirm Boolean @default(false)
    startedAt    DateTime  @default(now())
    endedAt      DateTime?
    Run          Run       @relation(fields: [runId], references: [id])
}

model RunScopedKey {
    id          Int      @id @default(autoincrement())
    runId       String
    provider    String
    scope       String
    tokenCipher Bytes
    expiresAt   DateTime
    Run         Run      @relation(fields: [runId], references: [id])
}

model RunEffect {
    id              Int      @id @default(autoincrement())
    runId           String
    stepId          Int?
    appId           String
    credentialId    Int
    action          String
    externalRef     String?
    idempotencyKey  String   @unique
    undoStrategy    String?
    canUndo         Boolean  @default(false)
    undoneAt        DateTime?
    metadata        Json?
    createdAt       DateTime @default(now())
    Run             Run      @relation(fields: [runId], references: [id])

    @@index([runId])
    @@index([idempotencyKey])
}

model LLMLog {
    id               Int      @id @default(autoincrement())
    userId           Int
    user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    teamId           Int?
    team             Team?    @relation(fields: [teamId], references: [id], onDelete: Cascade)
    prompt           String   @db.Text
    result           String   @db.Text
    promptTokens     Int      @default(0)
    completionTokens Int      @default(0)
    totalTokens      Int      @default(0)
    requestType      String
    apiEndpoint      String?
    model            String   @default("gpt-4o-mini")
    createdAt        DateTime @default(now())
    updatedAt        DateTime @updatedAt

    @@index([userId])
    @@index([teamId])
    @@index([createdAt])
    @@index([userId, createdAt])
}

model Credential {
    id                   Int       @id @default(autoincrement())
    type                 String
    key                  Json
    user                 User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId               Int?
    app                  App       @relation(fields: [appId], references: [slug], onDelete: Cascade)
    appId                String
    invalid              Boolean   @default(false)
    Team                 Team?     @relation(fields: [teamId], references: [id])
    teamId               Int?
    isUserCurrentProfile Boolean   @default(false)
    isTeamDefaultProfile Boolean   @default(false)
    emailOrUserName      String?
    avatarUrl            String?
    name                 String?
    vendorAccountId      String?
    tokenExpiresAt       DateTime?
    lastValidatedAt      DateTime?
    createdAt            DateTime  @default(now())
    updatedAt            DateTime  @updatedAt

    @@unique([userId, appId, emailOrUserName])
    @@index([userId])
    @@index([appId])
    @@index([teamId])
}

enum AppCategories {
    calendar
    email
    messaging
    other
    payment
    web3
    automation
    analytics
    conferencing
    crm
    social
    cloudstorage
    ai
    docs
    data
    devtools
    finance
}

model App {
    // The slug for the app store public page inside `/apps/[slug]`
    slug        String          @id @unique
    // The directory name for `/packages/app-store/[dirName]`
    dirName     String          @unique
    // Needed API Keys
    keys        Json?
    // One or multiple categories to which this app belongs
    categories  AppCategories[]
    createdAt   DateTime        @default(now())
    updatedAt   DateTime        @updatedAt
    credentials Credential[]
    ApiKey      ApiKey[]
    enabled     Boolean         @default(false)

    @@index([enabled])
}

model ApiKey {
    id         String    @id @unique @default(cuid())
    userId     Int
    note       String?
    createdAt  DateTime  @default(now())
    expiresAt  DateTime?
    lastUsedAt DateTime?
    hashedKey  String    @unique()
    user       User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
    app        App?      @relation(fields: [appId], references: [slug], onDelete: Cascade)
    appId      String?

    @@index([userId])
}

// Simple landing waitlist for beta signups
model Waitlist {
    id        Int      @id @default(autoincrement())
    email     String   @unique
    role      String?
    teamSize  String?
    useCase   String?
    createdAt DateTime @default(now())
}

// Templates for dashboard/chat prefills
model Template {
    id           String   @id @default(uuid())
    kind         String
    label        String
    sampleText   String
    icon         String?  // SVG icon as string
    category     String?  // e.g., "triage", "follow-ups", "meeting-prep", etc.
    variables    Json?
    locale       String   @default("en")
    isDefault    Boolean  @default(false)
    isUserCustom Boolean  @default(false)
    createdBy    String?
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt
}

// Email actions for undo capability (60-minute window)
model EmailAction {
    id             Int       @id @default(autoincrement())
    userId         String
    runId          String
    messageId      String
    threadId       String
    action         String    // 'SENT', 'UNDONE'
    canUndo        Boolean   @default(true)
    undoExpiresAt  DateTime?
    undoneAt       DateTime?
    createdAt      DateTime  @default(now())

    @@index([messageId])
    @@index([userId])
    @@index([runId])
    @@index([undoExpiresAt])
}
